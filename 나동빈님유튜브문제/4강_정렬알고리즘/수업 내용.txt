정렬 알고리즘

1) 선택 정렬
처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복
O(N2)
공간 복잡도 : O(N)

2) 삽입 정렬
처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
첫 번째가 값은 정렬되어있다고 판단한 후 두번째 값을 첫번째와 비교하여 첫 번째 값의 왼쪽에 들어갈지 오른쪽에 들어갈지 결정
세 번째 값이 첫 번째 값과 두 번째 값과 비교한 후 0, 1, 2 인덱스 중 알맞은 자리를 결정
같은 방법으로 반복
구현은 힘들지만, 선택 정렬보다 효율적
O(N2)
최선의 경우 O(N), 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작
공간 복잡도 : O(N)

3) 퀵 정렬
기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나
병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘
가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정

리스트의 왼쪽부터 피벗보다 큰 값을 선택하고 오른쪽부터 피벗보다 작은 값을 선택하여 스왑함
엇갈리는 경우 피벗과 작은 값을 스왑함
=> 분할 완료 -> 피벗을 기준으로 왼쪽은 피벗보다 큰 값 오른쪽은 피벗보다 작은값으로 분할
오른쪽 묶음과 왼쪽 묶음에 대하여
다시 첫 번째 값을 피벗으로 동일하게 반복

평균 : O(NlogN) => 표준 라이브러는 보장함
최악의 경우 : O(N)
공간 복잡도 : O(N)

4) 계수 정렬
특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작 : 동일한 값을 가지는 데이터가 여러 개 등장할 때 ex) 성적을 정렬할 때 (0~100점으로 제한 되어 있고 같은 값을 가지는 사람이 많음)
계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능
데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N+K)를 보장
공간 복잡도 높음 (O(N + K))




